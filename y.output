Grammar

    0 $accept: prog $end

    1 prog: inst PV
    2     | prog inst PV

    3 inst: let_def
    4     | exp

    5 let_def: def_id
    6        | def_fun

    7 def_id: LET ID EQ exp

    8 def_fun: LET fun_head EQ exp

    9 fun_head: ID LPAR id_list RPAR

   10 id_list: ID
   11        | id_list VIR ID

   12 exp: arith_exp
   13    | let_exp

   14 arith_exp: MOINS arith_exp
   15          | arith_exp MOINS arith_exp
   16          | arith_exp PLUS arith_exp
   17          | arith_exp DIV arith_exp
   18          | arith_exp MULT arith_exp
   19          | arith_exp CONCAT arith_exp
   20          | atom_exp

   21 atom_exp: NUM
   22         | FLOAT
   23         | STRING
   24         | ID
   25         | control_exp
   26         | funcall_exp
   27         | LPAR exp RPAR

   28 control_exp: if_exp

   29 if_exp: if cond then atom_exp else atom_exp

   30 if: IF

   31 cond: LPAR bool RPAR

   32 then: THEN

   33 else: ELSE

   34 let_exp: let_def IN atom_exp
   35        | let_def IN let_exp

   36 funcall_exp: fid LPAR arg_list RPAR

   37 fid: ID

   38 arg_list: arith_exp
   39         | arg_list VIR arith_exp

   40 bool: BOOL
   41     | bool OR bool
   42     | bool AND bool
   43     | NOT bool
   44     | exp comp exp
   45     | LPAR bool RPAR

   46 comp: ISLT
   47     | ISGT
   48     | ISLEQ
   49     | ISGEQ
   50     | ISEQ


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    NUM <val_int> (258) 21
    FLOAT <val_float> (259) 22
    ID <val_string> (260) 7 9 10 11 24 37
    STRING <val_string> (261) 23
    PV (262) 1 2
    LPAR (263) 9 27 31 36 45
    RPAR (264) 9 27 31 36 45
    LET (265) 7 8
    IN (266) 34 35
    VIR (267) 11 39
    IF (268) 30
    THEN (269) 32
    ELSE (270) 33
    ISLT <val_string> (271) 46
    ISGT <val_string> (272) 47
    ISLEQ <val_string> (273) 48
    ISGEQ <val_string> (274) 49
    ISEQ <val_string> (275) 50
    AND (276) 42
    OR (277) 41
    NOT (278) 43
    BOOL (279) 40
    PLUS (280) 16
    MOINS (281) 14 15
    MULT (282) 18
    DIV (283) 17
    EQ (284) 7 8
    CONCAT (285) 19
    UNA (286)


Nonterminals, with rules where they appear

    $accept (32)
        on left: 0
    prog (33)
        on left: 1 2
        on right: 0 2
    inst (34)
        on left: 3 4
        on right: 1 2
    let_def (35)
        on left: 5 6
        on right: 3 34 35
    def_id <val_string> (36)
        on left: 7
        on right: 5
    def_fun (37)
        on left: 8
        on right: 6
    fun_head <val_string> (38)
        on left: 9
        on right: 8
    id_list (39)
        on left: 10 11
        on right: 9 11
    exp <val_int> (40)
        on left: 12 13
        on right: 4 7 8 27 44
    arith_exp <val_int> (41)
        on left: 14 15 16 17 18 19 20
        on right: 12 14 15 16 17 18 19 38 39
    atom_exp <val_int> (42)
        on left: 21 22 23 24 25 26 27
        on right: 20 29 34
    control_exp (43)
        on left: 28
        on right: 25
    if_exp (44)
        on left: 29
        on right: 28
    if <val_int> (45)
        on left: 30
        on right: 29
    cond (46)
        on left: 31
        on right: 29
    then <val_int> (47)
        on left: 32
        on right: 29
    else <val_int> (48)
        on left: 33
        on right: 29
    let_exp (49)
        on left: 34 35
        on right: 13 35
    funcall_exp <val_string> (50)
        on left: 36
        on right: 26
    fid <val_string> (51)
        on left: 37
        on right: 36
    arg_list <val_int> (52)
        on left: 38 39
        on right: 36 39
    bool (53)
        on left: 40 41 42 43 44 45
        on right: 31 41 42 43 45
    comp <val_string> (54)
        on left: 46 47 48 49 50
        on right: 44


State 0

    0 $accept: • prog $end

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    prog         go to state 9
    inst         go to state 10
    let_def      go to state 11
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 14
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 1

   21 atom_exp: NUM •

    $default  reduce using rule 21 (atom_exp)


State 2

   22 atom_exp: FLOAT •

    $default  reduce using rule 22 (atom_exp)


State 3

   24 atom_exp: ID •
   37 fid: ID •

    LPAR      reduce using rule 37 (fid)
    $default  reduce using rule 24 (atom_exp)


State 4

   23 atom_exp: STRING •

    $default  reduce using rule 23 (atom_exp)


State 5

   27 atom_exp: LPAR • exp RPAR

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 24
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 6

    7 def_id: LET • ID EQ exp
    8 def_fun: LET • fun_head EQ exp

    ID  shift, and go to state 25

    fun_head  go to state 26


State 7

   30 if: IF •

    $default  reduce using rule 30 (if)


State 8

   14 arith_exp: MOINS • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 27
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 9

    0 $accept: prog • $end
    2 prog: prog • inst PV

    $end    shift, and go to state 28
    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    inst         go to state 29
    let_def      go to state 11
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 14
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 10

    1 prog: inst • PV

    PV  shift, and go to state 30


State 11

    3 inst: let_def •
   34 let_exp: let_def • IN atom_exp
   35        | let_def • IN let_exp

    IN  shift, and go to state 31

    $default  reduce using rule 3 (inst)


State 12

    5 let_def: def_id •

    $default  reduce using rule 5 (let_def)


State 13

    6 let_def: def_fun •

    $default  reduce using rule 6 (let_def)


State 14

    4 inst: exp •

    $default  reduce using rule 4 (inst)


State 15

   12 exp: arith_exp •
   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    PLUS    shift, and go to state 32
    MOINS   shift, and go to state 33
    MULT    shift, and go to state 34
    DIV     shift, and go to state 35
    CONCAT  shift, and go to state 36

    $default  reduce using rule 12 (exp)


State 16

   20 arith_exp: atom_exp •

    $default  reduce using rule 20 (arith_exp)


State 17

   25 atom_exp: control_exp •

    $default  reduce using rule 25 (atom_exp)


State 18

   28 control_exp: if_exp •

    $default  reduce using rule 28 (control_exp)


State 19

   29 if_exp: if • cond then atom_exp else atom_exp

    LPAR  shift, and go to state 37

    cond  go to state 38


State 20

   13 exp: let_exp •

    $default  reduce using rule 13 (exp)


State 21

   26 atom_exp: funcall_exp •

    $default  reduce using rule 26 (atom_exp)


State 22

   36 funcall_exp: fid • LPAR arg_list RPAR

    LPAR  shift, and go to state 39


State 23

   34 let_exp: let_def • IN atom_exp
   35        | let_def • IN let_exp

    IN  shift, and go to state 31


State 24

   27 atom_exp: LPAR exp • RPAR

    RPAR  shift, and go to state 40


State 25

    7 def_id: LET ID • EQ exp
    9 fun_head: ID • LPAR id_list RPAR

    LPAR  shift, and go to state 41
    EQ    shift, and go to state 42


State 26

    8 def_fun: LET fun_head • EQ exp

    EQ  shift, and go to state 43


State 27

   14 arith_exp: MOINS arith_exp •
   15          | arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    $default  reduce using rule 14 (arith_exp)


State 28

    0 $accept: prog $end •

    $default  accept


State 29

    2 prog: prog inst • PV

    PV  shift, and go to state 44


State 30

    1 prog: inst PV •

    $default  reduce using rule 1 (prog)


State 31

   34 let_exp: let_def IN • atom_exp
   35        | let_def IN • let_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    atom_exp     go to state 45
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 46
    funcall_exp  go to state 21
    fid          go to state 22


State 32

   16 arith_exp: arith_exp PLUS • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 47
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 33

   15 arith_exp: arith_exp MOINS • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 48
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 34

   18 arith_exp: arith_exp MULT • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 49
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 35

   17 arith_exp: arith_exp DIV • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 50
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 36

   19 arith_exp: arith_exp CONCAT • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 51
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 37

   31 cond: LPAR • bool RPAR

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 52
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    NOT     shift, and go to state 53
    BOOL    shift, and go to state 54
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 55
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22
    bool         go to state 56


State 38

   29 if_exp: if cond • then atom_exp else atom_exp

    THEN  shift, and go to state 57

    then  go to state 58


State 39

   36 funcall_exp: fid LPAR • arg_list RPAR

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 59
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22
    arg_list     go to state 60


State 40

   27 atom_exp: LPAR exp RPAR •

    $default  reduce using rule 27 (atom_exp)


State 41

    9 fun_head: ID LPAR • id_list RPAR

    ID  shift, and go to state 61

    id_list  go to state 62


State 42

    7 def_id: LET ID EQ • exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 63
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 43

    8 def_fun: LET fun_head EQ • exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 64
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 44

    2 prog: prog inst PV •

    $default  reduce using rule 2 (prog)


State 45

   34 let_exp: let_def IN atom_exp •

    $default  reduce using rule 34 (let_exp)


State 46

   35 let_exp: let_def IN let_exp •

    $default  reduce using rule 35 (let_exp)


State 47

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   16          | arith_exp PLUS arith_exp •
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    MULT    shift, and go to state 34
    DIV     shift, and go to state 35
    CONCAT  shift, and go to state 36

    $default  reduce using rule 16 (arith_exp)


State 48

   15 arith_exp: arith_exp • MOINS arith_exp
   15          | arith_exp MOINS arith_exp •
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    MULT    shift, and go to state 34
    DIV     shift, and go to state 35
    CONCAT  shift, and go to state 36

    $default  reduce using rule 15 (arith_exp)


State 49

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   18          | arith_exp MULT arith_exp •
   19          | arith_exp • CONCAT arith_exp

    CONCAT  shift, and go to state 36

    $default  reduce using rule 18 (arith_exp)


State 50

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   17          | arith_exp DIV arith_exp •
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    CONCAT  shift, and go to state 36

    $default  reduce using rule 17 (arith_exp)


State 51

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   19          | arith_exp CONCAT arith_exp •

    $default  reduce using rule 19 (arith_exp)


State 52

   27 atom_exp: LPAR • exp RPAR
   45 bool: LPAR • bool RPAR

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 52
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    NOT     shift, and go to state 53
    BOOL    shift, and go to state 54
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 65
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22
    bool         go to state 66


State 53

   43 bool: NOT • bool

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 52
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    NOT     shift, and go to state 53
    BOOL    shift, and go to state 54
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 55
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22
    bool         go to state 67


State 54

   40 bool: BOOL •

    $default  reduce using rule 40 (bool)


State 55

   44 bool: exp • comp exp

    ISLT   shift, and go to state 68
    ISGT   shift, and go to state 69
    ISLEQ  shift, and go to state 70
    ISGEQ  shift, and go to state 71
    ISEQ   shift, and go to state 72

    comp  go to state 73


State 56

   31 cond: LPAR bool • RPAR
   41 bool: bool • OR bool
   42     | bool • AND bool

    RPAR  shift, and go to state 74
    AND   shift, and go to state 75
    OR    shift, and go to state 76


State 57

   32 then: THEN •

    $default  reduce using rule 32 (then)


State 58

   29 if_exp: if cond then • atom_exp else atom_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7

    atom_exp     go to state 77
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 59

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   38 arg_list: arith_exp •

    PLUS    shift, and go to state 32
    MOINS   shift, and go to state 33
    MULT    shift, and go to state 34
    DIV     shift, and go to state 35
    CONCAT  shift, and go to state 36

    $default  reduce using rule 38 (arg_list)


State 60

   36 funcall_exp: fid LPAR arg_list • RPAR
   39 arg_list: arg_list • VIR arith_exp

    RPAR  shift, and go to state 78
    VIR   shift, and go to state 79


State 61

   10 id_list: ID •

    $default  reduce using rule 10 (id_list)


State 62

    9 fun_head: ID LPAR id_list • RPAR
   11 id_list: id_list • VIR ID

    RPAR  shift, and go to state 80
    VIR   shift, and go to state 81


State 63

    7 def_id: LET ID EQ exp •

    $default  reduce using rule 7 (def_id)


State 64

    8 def_fun: LET fun_head EQ exp •

    $default  reduce using rule 8 (def_fun)


State 65

   27 atom_exp: LPAR exp • RPAR
   44 bool: exp • comp exp

    RPAR   shift, and go to state 40
    ISLT   shift, and go to state 68
    ISGT   shift, and go to state 69
    ISLEQ  shift, and go to state 70
    ISGEQ  shift, and go to state 71
    ISEQ   shift, and go to state 72

    comp  go to state 73


State 66

   41 bool: bool • OR bool
   42     | bool • AND bool
   45     | LPAR bool • RPAR

    RPAR  shift, and go to state 82
    AND   shift, and go to state 75
    OR    shift, and go to state 76


State 67

   41 bool: bool • OR bool
   42     | bool • AND bool
   43     | NOT bool •

    $default  reduce using rule 43 (bool)


State 68

   46 comp: ISLT •

    $default  reduce using rule 46 (comp)


State 69

   47 comp: ISGT •

    $default  reduce using rule 47 (comp)


State 70

   48 comp: ISLEQ •

    $default  reduce using rule 48 (comp)


State 71

   49 comp: ISGEQ •

    $default  reduce using rule 49 (comp)


State 72

   50 comp: ISEQ •

    $default  reduce using rule 50 (comp)


State 73

   44 bool: exp comp • exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 83
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22


State 74

   31 cond: LPAR bool RPAR •

    $default  reduce using rule 31 (cond)


State 75

   42 bool: bool AND • bool

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 52
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    NOT     shift, and go to state 53
    BOOL    shift, and go to state 54
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 55
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22
    bool         go to state 84


State 76

   41 bool: bool OR • bool

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 52
    LET     shift, and go to state 6
    IF      shift, and go to state 7
    NOT     shift, and go to state 53
    BOOL    shift, and go to state 54
    MOINS   shift, and go to state 8

    let_def      go to state 23
    def_id       go to state 12
    def_fun      go to state 13
    exp          go to state 55
    arith_exp    go to state 15
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    let_exp      go to state 20
    funcall_exp  go to state 21
    fid          go to state 22
    bool         go to state 85


State 77

   29 if_exp: if cond then atom_exp • else atom_exp

    ELSE  shift, and go to state 86

    else  go to state 87


State 78

   36 funcall_exp: fid LPAR arg_list RPAR •

    $default  reduce using rule 36 (funcall_exp)


State 79

   39 arg_list: arg_list VIR • arith_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7
    MOINS   shift, and go to state 8

    arith_exp    go to state 88
    atom_exp     go to state 16
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 80

    9 fun_head: ID LPAR id_list RPAR •

    $default  reduce using rule 9 (fun_head)


State 81

   11 id_list: id_list VIR • ID

    ID  shift, and go to state 89


State 82

   45 bool: LPAR bool RPAR •

    $default  reduce using rule 45 (bool)


State 83

   44 bool: exp comp exp •

    $default  reduce using rule 44 (bool)


State 84

   41 bool: bool • OR bool
   42     | bool • AND bool
   42     | bool AND bool •

    $default  reduce using rule 42 (bool)


State 85

   41 bool: bool • OR bool
   41     | bool OR bool •
   42     | bool • AND bool

    AND  shift, and go to state 75

    $default  reduce using rule 41 (bool)


State 86

   33 else: ELSE •

    $default  reduce using rule 33 (else)


State 87

   29 if_exp: if cond then atom_exp else • atom_exp

    NUM     shift, and go to state 1
    FLOAT   shift, and go to state 2
    ID      shift, and go to state 3
    STRING  shift, and go to state 4
    LPAR    shift, and go to state 5
    IF      shift, and go to state 7

    atom_exp     go to state 90
    control_exp  go to state 17
    if_exp       go to state 18
    if           go to state 19
    funcall_exp  go to state 21
    fid          go to state 22


State 88

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   39 arg_list: arg_list VIR arith_exp •

    PLUS    shift, and go to state 32
    MOINS   shift, and go to state 33
    MULT    shift, and go to state 34
    DIV     shift, and go to state 35
    CONCAT  shift, and go to state 36

    $default  reduce using rule 39 (arg_list)


State 89

   11 id_list: id_list VIR ID •

    $default  reduce using rule 11 (id_list)


State 90

   29 if_exp: if cond then atom_exp else atom_exp •

    $default  reduce using rule 29 (if_exp)
